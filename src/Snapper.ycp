/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	modules/Snapper.ycp
 * Summary:	Snapper settings, input and output functions
 * Authors:	Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of snapper.
 * Input and output routines.
 */

{

module "Snapper";
textdomain "snapper";

import "FileUtils";
import "Label";
import "Progress";


// global list of all snapshot
global list<map> snapshots	= [];

global string snapshots_path	= "/snapshots"; // FIXME

global map selected_snapshot	= $[];

// mapping of snapshot number to index in snapshots list
global map<integer,integer> id2index	= $[];

// index to snapshots list
global integer selected_snapshot_index	= 0;

/**
 * Return list of files modified between given snapshots
 * File is a map with name (path) and some parameters
 */
global map<string, map> ReadModifiedFiles (integer from, integer to) {
    return (map<string, map>) SCR::Read (.snapper.diff_tree, $[ "from" : from, "to" : to]);
}

/**
 * Describe what was done with given file between given snapshots
 * - when new is 0, meaning is 'current system'
 */
global map GetFileModification (string file, integer old, integer new) {

    map ret	= $[];

    string file1	= sformat ("%1/%2/snapshot%3", snapshots_path, old, file);
    string file2	= sformat ("%1/%2/snapshot%3", snapshots_path, new, file);
    if (new == 0)
	file2	= file;

    y2milestone ("comparing '%1' and '%2'", file1, file2);

    if (FileUtils::Exists (file1) && FileUtils::Exists (file2))
    {
	list<string> status	= [ "no_change" ];
	map out	= (map) SCR::Execute (.target.bash_output,
	    sformat ("/usr/bin/diff -u %1 %2", file1, file2));
	if (out["stderr"]:"" != "")
	{
	    y2warning ("out: %1", out);
	    ret["diff"] = out["stderr"]:"";
	}
	// the file diff
	else if (out["stdout"]:nil != "")
	{
	    status	= ["diff"];
	    ret["diff"]	= out["stdout"]:"";
	}

	// check mode and ownerships
	out = (map) SCR::Execute (.target.bash_output,
	    sformat ("ls -l %1 %2 | cut -f 1,3,4 -d ' '", file1, file2));
	list<string> parts	= splitstring (out["stdout"]:""," \n");

	if (parts[0]:"" != parts[3]:"")
	{
	    status		= add (status, "mode");
	    ret["mode1"]	= parts[0]:"";
	    ret["mode2"]	= parts[3]:"";
	}
	if (parts[1]:"" != parts[4]:"")
	{
	    status		= add (status, "user");
	    ret["user1"]	= parts[1]:"";
	    ret["user2"]	= parts[4]:"";
	}
	if (parts[2]:"" != parts[5]:"")
	{
	    status		= add (status, "group");
	    ret["group1"]	= parts[2]:"";
	    ret["group2"]	= parts[5]:"";
	}
	ret["status"]	= status;
    }
    else if (FileUtils::Exists (file1))
    {
	ret["status"]	= ["removed"];
    }
    else if (FileUtils::Exists (file2))
    {
	ret["status"]	= ["created"];
    }
    else
    {
	ret["status"]	= ["none"];
    }
    return ret;
}

/**
 * Read the list of snapshots
 */
global boolean ReadSnapshots () {


    list<map> snapshot_maps	= (list<map>) SCR::Read (.snapper.snapshots);
    if (snapshot_maps == nil) snapshot_maps = [];
    integer i	= 0;
    foreach (map snapshot, snapshot_maps, {
	integer id	= snapshot["num"]:0;
	if (id == 0) return; // ignore the 'current system'
	snapshot["name"]	= tostring (id);
	y2debug ("snapshot data: %1", snapshot);
	snapshots	= add (snapshots, snapshot);
	id2index[id]	= i;
	i		= i + 1;
    });


    return true;
}

/**
 * Read all snapper settings
 * @return true on success
 */
global boolean Read() {

    /* Snapper read dialog caption */
    string caption = _("Initializing Snapper");

    integer steps = 2;

    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    /* Progress stage 1/3 */
	    _("Read the list of snapshots"),
	], [
	    /* Progress step 1/3 */
	    _("Reading the database..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    Progress::NextStage();
    // read database

    ReadSnapshots ();

    Progress::NextStage();
    return true;
}

/**
 * Copy given files from selected snapshot to current filesystem
 */
global boolean RestoreFiles (integer snapshot_num, list<string> files) {

    boolean ret	= true;
    y2milestone ("going to restore files %1", files);

    UI::OpenDialog (`opt (`decorated), `HBox (`HSpacing(1.5), `VBox (
	`HSpacing (60),
	// label for log window
	`LogView (`id (`log), _("Restoring Files..."), 8, 0),
	`ProgressBar (`id (`progress), "", size (files), 0),
	`PushButton (`id (`ok), Label::OKButton ())
    ), `HSpacing (1.5)));

    UI::ChangeWidget (`id (`ok), `Enabled, false);
    integer progress	= 0;
    foreach (string file, files, {

	UI::ChangeWidget (`id (`progress ), `Value, progress);

	string orig	= sformat ("%1/%2/snapshot%3", snapshots_path, snapshot_num, file);

	string dir	= substring (file, 0, findlastof (file, "/"));
	y2milestone ("copying file %1 to %2 (dir: %3)", orig, file, dir);
	if (FileUtils::CheckAndCreatePath (dir))
	{
	    SCR::Execute (.target.bash, sformat ("/bin/cp -a %1 %2", orig, file));
	    UI::ChangeWidget (`id (`log), `LastLine, file + "\n");
	}
	else
	{
	    // log entry (%1 is file name)
	    UI::ChangeWidget (`id (`log), `LastLine, sformat (_("%1 skipped\n"), file));
	}
	sleep (100);
	progress        = progress + 1;
    });

    UI::ChangeWidget (`id (`progress ), `Value, progress);
    UI::ChangeWidget (`id (`ok), `Enabled, true);

    UI::UserInput ();
    UI::CloseDialog ();

    return ret;
}


/* EOF */
}
